# 데이터베이스의 실행순서
설계는 요구사항 분석 → 개념적 설계 → 논리적 설계 → 물리적 설계 → 구현 <br> 
쿼리 실행은 FROM → JOIN → WHERE → GROUP BY → HAVING → SELECT → ORDER BY 
# 테이블 생성
```sql
CREATE TABLE Student (
    student_id   INT AUTO_INCREMENT PRIMARY KEY,
    name         VARCHAR(50) NOT NULL,
    email        VARCHAR(100) NOT NULL UNIQUE,
    phone        VARCHAR(20),
    reg_date     DATETIME DEFAULT CURRENT_TIMESTAMP
);
CREATE TABLE Course (
    course_id   INT AUTO_INCREMENT PRIMARY KEY,
    title       VARCHAR(100) NOT NULL,
    instructor  VARCHAR(50) NOT NULL,
    fee         INT NOT NULL CHECK (fee >= 0),
    opened_at   DATE NOT NULL
);
CREATE TABLE Enrollment (
    enrollment_id   INT AUTO_INCREMENT PRIMARY KEY,
    student_id      INT NOT NULL,
    course_id       INT NOT NULL,
    enrolled_at     DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    payment_status  ENUM('PAID', 'CANCEL') NOT NULL,
    CONSTRAINT fk_enroll_student
        FOREIGN KEY (student_id)
        REFERENCES Student(student_id)
        ON DELETE CASCADE,
    CONSTRAINT fk_enroll_course
        FOREIGN KEY (course_id)
        REFERENCES Course(course_id)
        ON DELETE CASCADE
);
CREATE TABLE Exam (
    exam_id     INT AUTO_INCREMENT PRIMARY KEY,
    course_id   INT NOT NULL,
    exam_name   VARCHAR(100) NOT NULL,
    exam_date   DATE NOT NULL,
    CONSTRAINT fk_exam_course
        FOREIGN KEY (course_id)
        REFERENCES Course(course_id)
        ON DELETE CASCADE
);
CREATE TABLE Score (
    score_id    INT AUTO_INCREMENT PRIMARY KEY,
    student_id  INT NOT NULL,
    exam_id     INT NOT NULL,
    score       INT,
    CONSTRAINT fk_score_student
        FOREIGN KEY (student_id)
        REFERENCES Student(student_id)
        ON DELETE CASCADE,
    CONSTRAINT fk_score_exam
        FOREIGN KEY (exam_id)
        REFERENCES Exam(exam_id)
        ON DELETE CASCADE
);

```

## 외래키 제약 조건 예
```sql
CREATE TABLE Member (
    id INT PRIMARY KEY,
    name VARCHAR(100)
);

CREATE TABLE Orders (
    id INT PRIMARY KEY,
    member_id INT,
    FOREIGN KEY (member_id) REFERENCES Member(id)
        ON DELETE CASCADE
        ON UPDATE CASCADE
);
```

## 컬럼 추가
```sql
ALTER TABLE Student ADD birth_date DATE;
```

## 컬럼 변경
```sql
ALTER TABLE Course MODIFY instructor VARCHAR(80) NOT NULL;
```
## 테이블 이름 변경
```sql
ALTER TABLE Exam RENAME TO ExamInfo;
```
## 제약 조건 추가
```sql
ALTER TABLE score ADD CONSTRAINT score_ck CHECK (score BETWEEN 0 AND 100);
```
## Update/Delete
```sql
UPDATE Enrollment SET payment_status = 'PAID' WHERE payment_status = 'CANCEL';
```
```sql
DELETE FROM Course WHERE fee >= 100000;
```
## LIKE
```sql
SELECT * FROM Student WHERE name LIKE '%김%';
```
## SUBSTR(Subtract String),LENGTH
```sql
SELECT email, SUBSTR(email, INSTR(email, '@') + 1) AS domain FROM Student;
```
```sql
SELECT title, LENGTH(title) AS title_length FROM Course;
SELECT title, CHAR_LENGTH(title) AS title_length FROM Course;
```
## DATE_SUB, NOW
```sql
SELECT * FROM Enrollment WHERE enrolled_at >= DATE_SUB(NOW(), INTERVAL 7 DAY);
```
## 합계 (SUM) = price와 quantity를 곱한후 전부 합한다
```sql
SELECT SUM(price * quantity) AS total_sales
FROM Sales;
```
## COUNT
NULL 포함
```sql
SELECT COUNT(*) AS total_rows FROM Sales;
```
NULL 제외
```sql
SELECT COUNT(column) AS total_rows FROM Sales;
```
## 평균 (AVG)
```sql
SELECT AVG(quantity) AS avg_q
FROM Sales;
```
## MAX
```sql
SELECT MAX(price) AS max_price FROM Sales;
```
## GROUB BY 
GROUP BY 는 반드시 집계 함수와 함께 사용된다 <br>
✔ COUNT() ✔ SUM() ✔ AVG() ✔ MAX() ✔ MIN() <br>
ex) 과목별 평균점수
```sql
SELECT subject, AVG(score) AS avg_score
FROM StudentScore
GROUP BY subject;
```
ex2) 학생별 총점
```sql
SELECT name, SUM(score) AS total_score
FROM StudentScore
GROUP BY name;
```
ex3) 과목별 최고 점수
```sql
SELECT subject, MAX(score) AS max_score
FROM StudentScore
GROUP BY subject;
```
ex)4 출석률(attendance) 구간별 인원 수
```sql
SELECT 
    CASE 
        WHEN attendance >= 90 THEN '우수'
        WHEN attendance >= 70 THEN '보통'
        ELSE '부족'
    END AS attendance_level,
    COUNT(*) AS cnt
FROM StudentScore
GROUP BY attendance_level;
```
## HAVING
WHERE: 그룹핑 이전 개별 로우에 조건 적용 <br>
HAVING: 그룹핑 이후 요약된 결과에 조건 적용 <br>
ex1) 과목별 평균 점수가 70 점 이상일때
```sql
SELECT subject, AVG(score) AS avg_score
FROM StudentScore
GROUP BY subject
HAVING AVG(score) >= 70;
```
## 집계함수 + GROUP BY + LEFT JOIN
```sql
SELECT c.course_id, c.title, COUNT(e.enrollment_id) AS enroll_count 
FROM Course c 
LEFT JOIN Enrollment e ON c.course_id = e.course_id 
GROUP BY c.course_id, c.title;
```
## INNER JOIN
```sql
SELECT s.student_id, s.name, AVG(sc.score) AS avg_score 
FROM student s
INNER JOIN score sc ON s.student_id = sc.student_id 
GROUP BY s.student_id, s.name;
```
```sql
SELECT c.course_id, c.title, c.fee, count(e.enrollment_id) AS student_count, c.fee * count(e.enrollment_id) AS total_revenue
FROM course c 
JOIN enrollment e ON c.course_id = e.course_id 
WHERE e.payment_status = 'PAID'
group by c.course_id, c.title, c.fee;
```
```sql
SELECT instructor, COUNT(*) AS course_count FROM Course GROUP BY instructor;
```
```sql
SELECT ei.exam_id, ei.exam_name, MAX(sc.score) AS max_score, MIN(sc.score) AS min_score
FROM examInfo ei 
JOIN score sc ON ei.exam_id = sc.exam_id
GROUP BY ei.exam_id, ei.exam_name;
```
```sql
SELECT s.name AS student_name, c.title AS course_title 
FROM student s
JOIN enrollment e ON s.student_id = e.student_id 
JOIN course c ON e.course_id = c.course_id;
```
수강에 등록되지 않은 학생을 찾는 쿼리
```sql
SELECT s.student_id, s.name 
FROM student s 
LEFT JOIN enrollment e ON s.student_id = e.student_id 
WHERE e.enrollment_id IS NULL;
```
시험 정보가 등록되지 않은 과목 목록을 조회하는 쿼리
```sql
SELECT c.course_id, c.title 
FROM course c
LEFT JOIN examInfo ei ON c.course_id = ei.course_id 
WHERE ei.exam_id IS NULL
```
# 세게 이상 테이블 조인
```sql
SELECT s.name AS student_name, c.title AS course_title, ei.exam_name, sc.score
FROM student s 
JOIN score sc ON s.student_id = sc.student_id -- R1(student join score)
JOIN examInfo ei ON sc.exam_id = ei.exam_id -- R2(R1 join examinfo)
JOIN course c ON ei.course_id = c.course_id; -- R3(R2 join course)
```
